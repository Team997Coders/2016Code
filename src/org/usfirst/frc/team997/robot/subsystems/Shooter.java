// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team997.robot.subsystems;

import org.usfirst.frc.team997.robot.Robot;
import org.usfirst.frc.team997.robot.RobotMap;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.smartdashboard.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class Shooter extends PIDSubsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController shooterMotor = RobotMap.shooterShooterMotor;
    private final SpeedController angleMotor = RobotMap.shooterAngleMotor;
    private final AnalogPotentiometer angleSensor = RobotMap.shooterAngleSensor;
    private final PIDController angleController = RobotMap.shooterAngleController;
    private final DigitalInput speedSensor = RobotMap.shooterSpeedSensor;
    private final Servo ballControlServoL = RobotMap.shooterBallControlServoL;
    private final Servo ballControlServoR = RobotMap.shooterBallControlServoR;
    private final AnalogInput ballDistSensor = RobotMap.shooterBallDistSensor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Counter shooterCounter;
	
    
	private double period = 1000.0;
    public boolean upLimit = false;
    public boolean downLimit = false;
    public boolean currentLimit = false;

    public Shooter() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
    	
        super("Shooter", 1.0, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("Shooter", "PIDSubsystem Controller", angleController);
        getPIDController().setInputRange(0.0, 5.0);
        getPIDController().setOutputRange(-0.5, 0.5);
        
		// Add in the counter to track the shooter wheel speed
		shooterCounter = new Counter();
		shooterCounter.setSamplesToAverage(15);
		shooterCounter.setUpSource(speedSensor);
		shooterCounter.setDistancePerPulse(1);



        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
    }


	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	// Note that all the shooter methods use 'period' and not 'speed/rpm' this
	// make the work
	// easier with one less inversion in the calculations. The sensor is
	// tracking time intervals
	// which aligns better with the period.
    
    public void init() {
    	this.stop();
       	ballControlServoL.set(RobotMap.shooterServoNeutralPoint);
    	ballControlServoR.set(1-RobotMap.shooterServoNeutralPoint);

    }

    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return angleSensor.get();

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }

    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        //armAngleMotor.pidWrite(output);
        this.rawAngleVoltage(output);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    }
    
    public void rawAngleVoltage(double voltage) {
    	// set the voltage into the gatherer arm motors (but impose limits)!
    	upLimit = false;
    	downLimit = false;
    	currentLimit = false;
    	
    	if (angleSensor.get() < RobotMap.shooterDownLimit) {
    		angleMotor.set(0);
    		downLimit = true;
    		return;
    	} else if (angleSensor.get() > RobotMap.shooterUpLimit) {
    		angleMotor.set(0);
    		upLimit = true;
    		return;
    	} else if (Robot.pdp.getCurrent(RobotMap.pdpShooterAngle) > RobotMap.shooterAngleCurrentLimit) {
    		angleMotor.set(0);
    		currentLimit = true;
    		return;
    	} else {
    		angleMotor.set(voltage);
    		return;
    	}
    }
    
    public void stop() {
    	shooterMotor.set(0);
    	angleMotor.set(0);
    }
    
    public double getBallDistance() {
    	return ballDistSensor.getAverageVoltage();
    }

    public boolean haveBall() {
    	return this.getBallDistance() < 0.1;
    }
    
    public void pushBall() {
    	ballControlServoL.set(RobotMap.shooterServoFirePoint);
    	ballControlServoR.set(1-RobotMap.shooterServoFirePoint);
    }
    
    public void grabBall() {
    	ballControlServoL.set(RobotMap.shooterServoCapturePoint);
    	ballControlServoR.set(1-RobotMap.shooterServoCapturePoint);
    }

    
    public boolean atSetpoint() {
    	return Math.abs(angleSensor.get() - this.getSetpoint()) > RobotMap.shooterAngleTolerance;
    }
        
	public double getPeriod() {
		return period;
	}

	public void spinup(double speed) {
		// this is just the initial spinup speed to apply to the wheels. The
		// next method will be used to track it.
		shooterMotor.set(speed);
		period = shooterCounter.getPeriod();
		SmartDashboard.putNumber("Shooter Period", period);
	}

	public void trackShooterSpeed(double setpoint) {
		// this routine should be called in the shooting loop to hold the
		// shooter
		// wheels at speed.
		period = shooterCounter.getPeriod();
		if (period < setpoint) {
			shooterMotor.set(0);
		} else {
			shooterMotor.set(1.0);
		}
		SmartDashboard.putNumber("Shooter Period setpoint", setpoint);
		SmartDashboard.putNumber("Shooter Period", period);
	}

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}
	
    public void updateDashboard() {
    	SmartDashboard.putNumber("Shooter Position", angleSensor.get());
    	SmartDashboard.putNumber("Shooter PID Setpoint", angleController.getSetpoint());
    	SmartDashboard.putBoolean("Shooter Up Limit", upLimit);
    	SmartDashboard.putBoolean("Shooter Down Limit", downLimit);
    	SmartDashboard.putBoolean("Shooter Current Limit", currentLimit);
    	SmartDashboard.putBoolean("Shooter PID Enabled?", angleController.isEnabled());
    }

}
